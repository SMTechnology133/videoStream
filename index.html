<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WebRTC Live Stream Client</title>

<style>
/* ... (your existing CSS unchanged) ... */
body {
    font-family: georgia;
    background: linear-gradient(to right, teal, maroon);
    border: 1px solid orange;
    border-radius: 4px;
    margin-top: 1px;
    color: orange;
    text-align: center;
    padding: 2px;
}
/* rest of your CSS remains the same */
footer, h1 {
    border: 1px solid orange;
    border-radius: 4px;
    background: teal;
    margin: 2px;
    padding: 10px;
    color: orange;
}
/* keep all your existing styles unchanged */
h2 {
    border: 1px solid orange;
    border-radius: 6px;
    background: maroon;
    margin: 20px;
    font-size: 14px;
    padding: 8px;
    color: orange;
    text-align: center;
}
.container { max-width: 1100px; margin: auto; }
header { margin-bottom: 20px; }
.grid { display: grid; grid-template-columns: 1fr; gap: 20px; }
@media (min-width: 768px) { .grid { grid-template-columns: 1fr 1fr; } }
.card {
    background: linear-gradient(to right, maroon, teal);
    padding: 2px;
    border-radius: 14px;
    box-shadow: 0px 4px 14px rgba(0,0,0,0.2);
    color: black;
    text-align: left;
    border:1px solid orange;
}
.video-container { position: relative; width: 100%; aspect-ratio: 16 / 9; }
.video-feed { width: 100%; height: 100%; background-color: #1f2937; border-radius: 10px; object-fit: cover; transform: scaleX(-1); }
#remoteVideo { transform: scaleX(1); }
button { padding: 10px 15px; border-radius: 8px; border: none; cursor: pointer; color: white; font-weight: bold; }
.btn-green { background: teal; color: orange; }
.btn-red { background: maroon; color: orange; }
.btn-blue { background: orange; color: gray; }
button:disabled { opacity: 0.5; cursor: not-allowed; }
.flex-row { display: flex; gap: 10px; margin-top: 15px; }
.flex-between { display: flex; justify-content: space-between; align-items: center; }
#remoteStatus { position: absolute; inset: 0; background: rgba(0,0,0,0.5); border-radius: 10px; color: white; font-size: 18px; display: flex; align-items: center; justify-content: center; }
#statusConsole {
    background: #f3f4f6;
    padding: 12px;
    border-radius: 12px;
    height: 140px;
    overflow-y: scroll;
    font-size: 14px;
    border: 1px solid orange;
    color: teal;
}
.login-screen input[type="text"] { width: 90%; padding: 6px; margin-top: 6px; border-radius: 6px; border:1px solid orange; }
.login-screen input[type="file"] { margin-top:6px; }
.previewPic { width:60px; height:60px; border-radius:50%; display:none; margin-top:6px; border:1px solid orange; }
#broadcasterList img { width:30px;height:30px;border-radius:50%;vertical-align:middle;margin-right:5px; }
#localPlaceholder { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; border-radius:10px; display:none; }

/* small grid styling for the broadcaster tiles (minimal, won't conflict) */
.broadcaster-tile {
    display:flex;
    align-items:center;
    gap:12px;
    padding:8px;
    border-radius:8px;
    margin-bottom:8px;
    cursor:pointer;
    transition: background 0.12s;
}
.broadcaster-tile:hover { background: rgba(0,0,0,0.06); }
.broadcaster-avatar { width:48px; height:48px; border-radius:50%; object-fit:cover; border:1px solid #ddd; }
.broadcaster-name { font-weight:600; color:#111; }
</style>
</head>

<body>
<div class="container">

<header>
<h1>Full Stack Live Stream</h1>

<div id="loginScreen" class="login-screen">
    <h2>Welcome</h2>

    <label>Your Name</label>
    <input type="text" id="usernameInput" placeholder="Enter your name">

    <label>Profile Picture</label>
    <input type="file" id="profilePicInput" accept="image/*">

    <img id="previewPic" class="previewPic"><br><br>

    <button id="saveProfileBtn">Save & Continue</button>
</div>

<p id="userIdDisplay" style="color:white;">Your: Connecting...</p>
<p id="broadcasterStatus" style="color:yellow;">Status: Waiting for Broadcaster.</p>
<p style="font-size:12px; margin-top:5px; color:lightcoral;">Note: P2P simulated connections.</p>
</header>

<div class="grid">

    <!-- LOCAL STREAM -->
    <div class="card">
        <h2>Your Camera</h2>
        <div class="video-container">
            <video id="localVideo" class="video-feed" autoplay playsinline muted></video>
            <img id="localPlaceholder" src="">
        </div>

        <div class="flex-row">
            <button id="startStreamBtn" onclick="startLocalStream(true)" class="btn-green">
                <span id="startText">Start Broadcast</span>
            </button>
            <button id="stopStreamBtn" onclick="stopLocalStream()" class="btn-red" disabled>Stop Broadcast</button>
        </div>

        <div class="flex-between" style="margin-top:15px;">
            <label>
                <input type="checkbox" id="frontCameraToggle" checked>
                <span style="margin-left:5px;">Use Front Camera</span>
            </label>

            <button id="connectBtn" onclick="requestConnectAsViewer()" class="btn-blue" disabled>
                Connect as Viewer
            </button>
        </div>

        <button id="changeProfileBtn" class="btn-blue" style="margin-top:10px; display:none;">
            Change Profile / Logout
        </button>
    </div>

    <!-- REMOTE STREAM -->
    <div class="card">
        <h2>Remote Broadcast Feed</h2>
        <div class="video-container">
            <video id="remoteVideo" class="video-feed" autoplay playsinline></video>
            <p id="remoteStatus">Awaiting Stream...</p>
        </div>
    </div>

</div><br>

<button onclick="toggleBroadcasterList()">Show Broadcasters ▼</button>
<div id="broadcasterList" style="display:none; background:white; color:black; padding:10px; margin:10px; border-radius:6px; border:1px solid orange;">
    Loading…
</div>

<div class="card" style="margin-top:20px;">
    <h3 style="margin-bottom:10px; text-align:center; color:teal;">System Console</h3>
    <div id="statusConsole"></div>
</div>

</div>
<footer style="font-size:10px;">&copy; 2025 Copyright SM Technology Live Streaming</footer>

<script>
/* ============================
   Client-side signaling & UI
   (updated: show names only, clickable broadcaster tiles)
   ============================ */

const WS_URL = (window.location.protocol === "https:" ? "wss://" : "ws://") + window.location.host;
let ws = null;
let pc = null;
let localStream = null;
let userId = null;        // internal id (not shown)
let username = null;      // shown in UI
let profilePic = null;
let activeBroadcasterId = null;
let activeBroadcasterName = null;
let isBroadcasting = false;
let queuedProfileSend = false; // if profile saved before ws open

const localVideo = document.getElementById("localVideo");
const localPlaceholder = document.getElementById("localPlaceholder");
const remoteVideo = document.getElementById("remoteVideo");
const remoteStatus = document.getElementById("remoteStatus");
const consoleEl = document.getElementById("statusConsole");

const startBtn = document.getElementById("startStreamBtn");
const stopBtn = document.getElementById("stopStreamBtn");
const connectBtn = document.getElementById("connectBtn");
const cameraToggle = document.getElementById("frontCameraToggle");
const userIdDisplay = document.getElementById("userIdDisplay");
const broadcasterStatus = document.getElementById("broadcasterStatus");

const broadcasterListEl = document.getElementById("broadcasterList");
const changeProfileBtn = document.getElementById("changeProfileBtn");
let broadcasterDropdownVisible = false;

const PEER_CONFIG = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

function log(msg) {
    const p = document.createElement("p");
    p.textContent = msg;
    consoleEl.appendChild(p);
    consoleEl.scrollTop = consoleEl.scrollHeight;
}

/* ---------------- LOGIN & PROFILE ---------------- */
window.onload = () => {
    const savedName = localStorage.getItem("username");
    const savedPic = localStorage.getItem("profilePic");

    if (savedName && savedPic) {
        username = savedName;
        profilePic = savedPic;
        document.getElementById("loginScreen").style.display = "none";

        localVideo.style.display = "none";
        localPlaceholder.src = profilePic;
        localPlaceholder.style.display = "block";

        changeProfileBtn.style.display = "inline-block";
        queuedProfileSend = true;
    }
};

document.getElementById("profilePicInput").addEventListener("change", function() {
    const file = this.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        document.getElementById("previewPic").src = e.target.result;
        document.getElementById("previewPic").style.display = "block";
    };
    reader.readAsDataURL(file);
});

document.getElementById("saveProfileBtn").addEventListener("click", () => {
    const nameInput = document.getElementById("usernameInput").value.trim();
    const picSrc = document.getElementById("previewPic").src;

    if (!nameInput) { alert("Enter your name"); return; }
    if (!picSrc || picSrc === "") { alert("Upload a picture"); return; }

    username = nameInput;
    profilePic = picSrc;

    localStorage.setItem("username", username);
    localStorage.setItem("profilePic", profilePic);

    document.getElementById("loginScreen").style.display = "none";
    localVideo.style.display = "none";
    localPlaceholder.src = profilePic;
    localPlaceholder.style.display = "block";
    changeProfileBtn.style.display = "inline-block";

    if (ws && ws.readyState === WebSocket.OPEN) {
        sendProfileToServer();
    } else {
        queuedProfileSend = true;
    }
});

changeProfileBtn.addEventListener("click", () => {
    stopLocalStream();
    localStorage.removeItem("username");
    localStorage.removeItem("profilePic");
    username = null;
    profilePic = null;

    localVideo.style.display = "none";
    localPlaceholder.src = "";
    localPlaceholder.style.display = "none";

    document.getElementById("loginScreen").style.display = "block";
    changeProfileBtn.style.display = "none";

    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "logout" }));
        ws.send(JSON.stringify({ type: "set_name", name: null }));
        ws.send(JSON.stringify({ type: "setProfile", username: null }));
    }
});

function sendProfileToServer() {
    if (!username) return;
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "setProfile", username: username, profilePic: profilePic }));
        // also support older server handlers
        ws.send(JSON.stringify({ type: "set_name", name: username }));
        queuedProfileSend = false;

        // show username only in UI
        userIdDisplay.textContent = username;
        log("Profile sent: " + username);
    } else {
        queuedProfileSend = true;
    }
}

/* ---------------- BROADCASTER DROPDOWN (grid) ---------------- */
function toggleBroadcasterList() {
    broadcasterDropdownVisible = !broadcasterDropdownVisible;
    broadcasterListEl.style.display = broadcasterDropdownVisible ? "block" : "none";
}

function updateBroadcasterDropdown(list) {
    // normalize
    const items = Array.isArray(list) ? list : (list && list.list) ? list.list : [];
    broadcasterListEl.innerHTML = "<h4>Available Broadcasters:</h4>";
    if (!items || items.length === 0) {
        broadcasterListEl.innerHTML += "<p>No broadcasters online.</p>";
        connectBtn.disabled = true;
        return;
    }

    connectBtn.disabled = true; // require selection

    items.forEach(b => {
        const entry = document.createElement("div");
        entry.className = "broadcaster-tile";

        const img = document.createElement("img");
        img.className = "broadcaster-avatar";
        img.src = b.profilePic || "";
        img.alt = b.name || "Anon";

        const nameDiv = document.createElement("div");
        nameDiv.className = "broadcaster-name";
        nameDiv.textContent = b.name || ("User");

        const joinBtn = document.createElement("button");
        joinBtn.className = "btn-blue";
        joinBtn.textContent = "Join";
        joinBtn.style.marginLeft = "auto";

        // tile click selects broadcaster
        function selectBroadcaster() {
            activeBroadcasterId = b.id;
            activeBroadcasterName = b.name || "Unknown";
            connectBtn.disabled = false;
            broadcasterStatus.textContent = "Selected Broadcaster: " + activeBroadcasterName;
        }

        entry.appendChild(img);
        entry.appendChild(nameDiv);
        entry.appendChild(joinBtn);

        // clicking anywhere selects + triggers immediate join
        entry.addEventListener("click", () => {
            selectBroadcaster();
            // automatically request connect
            requestConnectAsViewer();
        });

        // join button explicit action (also selects)
        joinBtn.addEventListener("click", (ev) => {
            ev.stopPropagation();
            selectBroadcaster();
            requestConnectAsViewer();
        });

        broadcasterListEl.appendChild(entry);
    });
}

/* ---------------- WEBSOCKET ---------------- */
function connectSignalingServer() {
    ws = new WebSocket(WS_URL);

    ws.onopen = () => {
        log("Connected to server");
        if (queuedProfileSend) sendProfileToServer();
    };

    ws.onmessage = (msg) => {
        let data;
        try { data = JSON.parse(msg.data); } catch (e) { return; }

        // server assigned internal id (do not show cryptic id to user)
        if (data.type === "id") {
            userId = data.id;
            // show username only if set
            if (username) userIdDisplay.textContent = username;
            else userIdDisplay.textContent = "You (not logged in)";
            return;
        }

        if (data.type === "broadcaster_list") {
            updateBroadcasterDropdown(data.list || data);
            return;
        }

        if (data.type === "broadcaster_started") {
            // update UI with name (no UUID shown)
            activeBroadcasterId = data.broadcasterId;
            activeBroadcasterName = data.broadcasterName || data.name || "Broadcaster";
            broadcasterStatus.textContent = "Broadcaster Online: " + activeBroadcasterName;
            if (data.list) updateBroadcasterDropdown(data.list);
            return;
        }

        if (data.type === "broadcaster_ended") {
            activeBroadcasterId = null;
            activeBroadcasterName = null;
            broadcasterStatus.textContent = "No active broadcaster.";
            remoteVideo.srcObject = null;
            remoteStatus.textContent = "Awaiting Stream...";
            if (data.list) updateBroadcasterDropdown(data.list);
            return;
        }

        if (data.type === "request_offer") {
            // broadcaster receives this when a viewer wants to join
            // includes viewerId and viewerName
            if (isBroadcasting && data.viewerId) {
                // ensure pc exists
                if (!pc) initPeerConnection();
                // create offer targeted to viewerId
                createOffer(data.viewerId);
                log("Creating offer for viewer: " + (data.viewerName || data.viewerId));
            }
            return;
        }

        if (data.type === "offer") {
            // viewer receives offer from broadcaster
            const fromId = data.senderId;
            const fromName = data.senderName || "Broadcaster";
            log("Received offer from: " + fromName);
            startLocalStream(false).then(() => createAnswer(data.sdp, fromId));
            return;
        }

        if (data.type === "answer") {
            if (pc) {
                pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
                log("Answer received from: " + (data.senderName || data.senderId));
            }
            return;
        }

        if (data.type === "candidate") {
            if (pc) {
                pc.addIceCandidate(new RTCIceCandidate(data.candidate)).catch(e => console.warn(e));
            }
            return;
        }

        // unknown message
        log("Unknown message: " + JSON.stringify(data));
    };

    ws.onclose = () => {
        log("Disconnected from signaling server - retrying...");
        setTimeout(connectSignalingServer, 1500);
    };

    ws.onerror = (e) => {
        console.warn("WebSocket error", e);
    };
}
connectSignalingServer();

/* ---------------- WEBRTC LOGIC ---------------- */
async function startLocalStream(isBroadcaster = false) {
    startBtn.disabled = true;
    stopBtn.disabled = false;

    const constraints = { video: { facingMode: cameraToggle.checked ? "user" : "environment" }, audio: true };

    try {
        localStream = await navigator.mediaDevices.getUserMedia(constraints);
        localVideo.srcObject = localStream;
        localVideo.style.display = "block";
        localPlaceholder.style.display = "none";
    } catch (err) {
        console.warn("Camera not available, showing profile picture.");
        localVideo.style.display = "none";
        localPlaceholder.src = profilePic || "";
        localPlaceholder.style.display = "block";
    }

    isBroadcasting = isBroadcaster;
    if (isBroadcasting) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: "start_broadcast", name: username || null }));
        } else {
            log("Cannot start broadcast: signaling not open");
        }
        broadcasterStatus.textContent = "YOU ARE BROADCASTING";
    }

    initPeerConnection();
}

function stopLocalStream() {
    stopBtn.disabled = true;
    startBtn.disabled = false;

    if (localStream) localStream.getTracks().forEach(t => t.stop());
    localStream = null;

    if (isBroadcasting && ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "stop_broadcast" }));
    }

    stopPeerConnection();

    localVideo.style.display = "none";
    localPlaceholder.src = profilePic || "";
    localPlaceholder.style.display = "block";

    remoteVideo.srcObject = null;
    remoteStatus.textContent = "Awaiting Stream...";

    isBroadcasting = false;
}

function initPeerConnection() {
    pc = new RTCPeerConnection(PEER_CONFIG);
    if (localStream) localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

    pc.ontrack = (event) => { remoteVideo.srcObject = event.streams[0]; remoteStatus.textContent = ""; };

    pc.onicecandidate = (event) => {
        if (event.candidate && ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: "candidate", candidate: event.candidate, targetId: pc.targetId }));
        }
    };
}

function stopPeerConnection() { if (pc) pc.close(); pc = null; }

async function createOffer(viewerId) {
    if (!pc) initPeerConnection();
    pc.targetId = viewerId;
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "offer", sdp: offer, targetId: viewerId }));
        log("Offer sent to viewer");
    }
}

async function createAnswer(offer, broadcasterId) {
    if (!pc) initPeerConnection();
    pc.targetId = broadcasterId;
    await pc.setRemoteDescription(new RTCSessionDescription(offer));
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "answer", sdp: answer, targetId: broadcasterId }));
        log("Answer sent to broadcaster");
    }
}

function requestConnectAsViewer() {
    // require a selected broadcaster tile (activeBroadcasterId)
    const targetId = activeBroadcasterId;
    const targetName = activeBroadcasterName || "Selected Broadcaster";
    if (!targetId) return alert("No broadcaster selected. Use 'Show Broadcasters' and pick one.");
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "request_offer", targetId, viewerId: userId }));
        log("Requested connection to broadcaster: " + targetName);
    } else {
        alert("Signaling connection not open.");
    }
}
</script>
</body>
</html>