<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>WebRTC Live Stream Client</title>

<style>
/* (Your original CSS preserved; small additions at bottom) */
body {
    font-family: georgia;
    background: linear-gradient(to right, teal, maroon);
    border: 1px solid orange;
    border-radius: 4px;
    margin-top: 1px;
    color: orange;
    text-align: center;
    padding: 2px;
}
footer, h1 {
    border: 1px solid orange;
    border-radius: 4px;
    background: teal;
    margin: 2px;
    padding: 10px;
    color: orange;
}
h2 {
    border: 1px solid orange;
    border-radius: 6px;
    background: maroon;
    margin: 20px;
    font-size: 14px;
    padding: 8px;
    color: orange;
    text-align: center;
}

.container {
	 max-width: 1100px;
	  margin: auto;
	   }
	   
header {
	 margin-bottom: 20px;
	  }
	  
.grid {
	 display: grid;
	  grid-template-columns: 1fr;
	   gap: 20px;
	    }
	    
@media (min-width: 768px) { .grid { grid-template-columns: 1fr 1fr; } }

.card {
    background: linear-gradient(to right, maroon, teal);
    padding: 2px;
    border-radius: 14px;
    box-shadow: 0px 4px 14px rgba(0,0,0,0.2);
    color: black;
    text-align: left;
    border:1px solid orange;
}

.video-container {
	 position: relative;
	  width: 100%;
	   aspect-ratio: 16 / 9;
	    }
	    
.video-feed {
	 width: 100%;
	  height: 100%;
	   background-color: #1f2937;
	    border-radius: 10px;
	     object-fit: cover;
	      transform: scaleX(-1);
	       }
	       
#remoteVideo {
	 transform: scaleX(1);
	  }
	  
button {
	 padding: 10px 15px;
	  border-radius: 8px;
	   border: none;
	    cursor: pointer;
	     color: white;
	      font-weight: bold;
	       }
	       
.btn-green {
	 background: teal;
	  color: orange;
	   }
	   
.btn-red {
	 background: maroon;
	  color: orange;
	   }
	   
.btn-blue {
	 background: orange;
	  color: gray;
	   }
	   
button:disabled {
	 opacity: 0.5;
	  cursor: not-allowed;
	   }
	   
.flex-row {
	 display: flex;
	  gap: 10px;
	   margin-top: 15px;
	    }
	    
.flex-between {
	 display: flex;
	  justify-content: space-between;
	   align-items: center;
	    }
	    
#remoteStatus {
	 position: absolute;
	  inset: 0;
	   background: rgba(0,0,0,0.5);
	    border-radius: 10px;
	     color: white;
	      font-size: 18px;
	       display: flex;
	        align-items: center;
	         justify-content: center;
	          }
	          
#statusConsole {
    background: #f3f4f6;
    padding: 12px;
    border-radius: 12px;
    height: 140px;
    overflow-y: scroll;
    font-size: 14px;
    border: 1px solid orange;
    color: teal;
}

.login-screen input[type="text"] {
	 width: 90%;
	  padding: 6px;
	   margin-top: 6px;
	    border-radius: 6px;
	     border:1px solid gray;
	     background:orange;
	     color:orange;
	      }
	      
.login-screen input[type="file"] {
	 margin-top:6px;
	 border:1px solid gray;
	 border-radius: 6px;
	 background:orange;
	 color:gray;
	 padding: 4px;
	  }
	  
.previewPic {
	 width:60px;
	  height:60px;
	   border-radius:50%;
	    display:none;
	     margin-top:6px;
	      border:1px solid orange;
	       }
	       
#broadcasterList img {
	 width:30px;
	 height:30px;
	 border-radius:50%;
	 vertical-align:middle;
	 margin-right:5px;
	  }
	  
	  
#localPlaceholder {
	 position:absolute;
	  inset:0; width:100%;
	   height:100%;
	    object-fit:cover;
	     border-radius:10px;
	      display:none;
	       }

/* small grid styling for the broadcaster tiles (minimal, won't conflict) */
.broadcaster-tile {
    display:flex;
    align-items:center;
    gap:12px;
    padding:8px;
    border-radius:8px;
    margin-bottom:8px;
    cursor:pointer;
    transition: background 0.12s, border 0.12s;
    border:1px solid rgba(0,0,0,0.04);
}

.broadcaster-tile:hover {
	 background: rgba(0,0,0,0.04);
	  }
	  
.broadcaster-avatar {
	 width:48px;
	  height:48px;
	   border-radius:50%;
	    object-fit:cover;
	     border:1px solid #ddd;
	      }
	      
.broadcaster-name {
	 font-weight:600;
	  color:#111;
	   }

/* NEW: highlight for joined/selected tile */
.broadcaster-tile.joined {
    background: rgba(34,197,94,0.12); /* light green */
    border: 1px solid rgba(34,197,94,0.28);
}

.broadcaster-tile .join-btn {
	 margin-left:auto;
	  }

.user-header {
    display:flex;
    align-items:center;
    gap:10px;
    justify-content:center;
    margin-bottom:6px;
}
.user-avatar {
    width:40px;
    height:40px;
    border-radius:50%;
    object-fit:cover;
    border: 1px solid orange;
}
.user-name {
	 font-weight:700;
	  color: white;
	   font-size:16px;
	    }
	    
	    label{
	    	text-decoration: underline;
	    }
</style>
</head>

<body>
<div class="container">

<header>
<h1>Africa Online Live Streaming</h1>

<div id="loginScreen" class="login-screen">
    <h2>Welcome</h2>

    <label>Your Name</label>
    <input type="text" id="usernameInput" placeholder="Enter your name">

    <label>Profile Picture</label>
    <input type="file" id="profilePicInput" accept="image/*">

    <img id="previewPic" class="previewPic"><br><br>

    <button style="border:1px solid orange; background:maroon; color:orange;" id="saveProfileBtn">Save & Continue</button>
</div>

<!-- NEW: user header shows avatar + name only (no UUID) -->
<div class="user-header" style="margin-top:10px;">
    <img id="topAvatar" class="user-avatar" src="" style="display:none" alt="avatar">
    <div id="userIdDisplay" class="user-name" style="color:white;">Your: Connecting...</div>
</div>

<p id="broadcasterStatus" style="color:yellow;">Status: Waiting for Broadcaster.</p>
<p style="font-size:12px; margin-top:5px; color:lightcoral;">Note: P2P simulated connections.</p>
</header>

<div class="grid">

    <!-- LOCAL STREAM -->
    <div class="card">
        <h2>Your Camera</h2>
        <div class="video-container">
            <video id="localVideo" class="video-feed" autoplay playsinline muted></video>
            <img id="localPlaceholder" src="">
        </div>

        <div class="flex-row">
            <button id="startStreamBtn" onclick="startLocalStream(true)" class="btn-green">
                <span id="startText">Start Broadcast</span>
            </button>
            <button id="stopStreamBtn" onclick="stopLocalStream()" class="btn-red" disabled>Stop Broadcast</button>
        </div>

        <div class="flex-between" style="margin-top:15px;">
            <label style="text-decoration: none;">
                <input type="checkbox" id="frontCameraToggle" checked>
                <span style="margin-left:5px; color: teal;">Use Front Camera</span>
            </label>

            <button id="connectBtn" onclick="requestConnectAsViewer()" class="btn-blue" disabled>
                Connect as Viewer
            </button>
        </div>

        <button id="changeProfileBtn" class="btn-blue" style="margin-top:10px; display:none;">
            Change Profile / Logout
        </button>
    </div>

    <!-- REMOTE STREAM -->
    <div class="card">
        <h2>Remote Broadcast Feed</h2>
        <div class="video-container">
            <video id="remoteVideo" class="video-feed" autoplay playsinline></video>
            <p id="remoteStatus">Awaiting Stream...</p>
        </div>
    </div>

</div><br>

<button style="border:1px solid orange; background:maroon; color:orange;" onclick="toggleBroadcasterList()">Show Broadcasters ▼</button>
<div id="broadcasterList" style="display:none; background:gray; color:black; padding:10px; margin:10px; border-radius:6px; border:1px solid orange;">
    Loading…
</div>

<div class="card" style="margin-top:20px;">
    <h3 style="margin-bottom:10px; text-align:center; color:teal;">System Console</h3>
    <div id="statusConsole"></div>
</div>

</div>
<footer style="font-size:10px;">&copy; 2025 Copyright SM Technology Live Streaming</footer>

<script>
/* ============================
 Client-side signaling & UI
 - shows avatar next to name at top
 - joined tile highlights & button text changes to "Joined"
 ============================ */

const WS_URL = (window.location.protocol === "https:" ? "wss://" : "ws://") + window.location.host;
let ws = null;
let pc = null;
let localStream = null;
let userId = null;        // internal id (hidden)
let username = null;      // visible name
let profilePic = null;
let activeBroadcasterId = null;   // tile selected
let activeBroadcasterName = null;
let joinedBroadcasterId = null;   // the broadcaster this client has joined as viewer
let isBroadcasting = false;
let queuedProfileSend = false;

const localVideo = document.getElementById("localVideo");
const localPlaceholder = document.getElementById("localPlaceholder");
const remoteVideo = document.getElementById("remoteVideo");
const remoteStatus = document.getElementById("remoteStatus");
const consoleEl = document.getElementById("statusConsole");

const startBtn = document.getElementById("startStreamBtn");
const stopBtn = document.getElementById("stopStreamBtn");
const connectBtn = document.getElementById("connectBtn");
const cameraToggle = document.getElementById("frontCameraToggle");
const userIdDisplay = document.getElementById("userIdDisplay");
const broadcasterStatus = document.getElementById("broadcasterStatus");

const broadcasterListEl = document.getElementById("broadcasterList");
const changeProfileBtn = document.getElementById("changeProfileBtn");
const topAvatar = document.getElementById("topAvatar");

const PEER_CONFIG = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

function log(msg) {
    const p = document.createElement("p");
    p.textContent = msg;
    consoleEl.appendChild(p);
    consoleEl.scrollTop = consoleEl.scrollHeight;
}

/* ---------------- LOGIN & PROFILE ---------------- */
window.onload = () => {
    const savedName = localStorage.getItem("username");
    const savedPic = localStorage.getItem("profilePic");

    if (savedName && savedPic) {
        username = savedName;
        profilePic = savedPic;
        document.getElementById("loginScreen").style.display = "none";
        localVideo.style.display = "none";
        localPlaceholder.src = profilePic;
        localPlaceholder.style.display = "block";
        changeProfileBtn.style.display = "inline-block";
        queuedProfileSend = true;
        // reflect immediately at top
        showTopProfile();
    }
};

function showTopProfile() {
    if (username) {
        userIdDisplay.textContent = username;
        if (profilePic) {
            topAvatar.src = profilePic;
            topAvatar.style.display = "inline-block";
        } else {
            topAvatar.style.display = "none";
        }
    } else {
        userIdDisplay.textContent = "You (not logged in)";
        topAvatar.style.display = "none";
    }
}

/* preview profile image */
document.getElementById("profilePicInput").addEventListener("change", function() {
    const file = this.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        document.getElementById("previewPic").src = e.target.result;
        document.getElementById("previewPic").style.display = "block";
    };
    reader.readAsDataURL(file);
});

/* save profile */
document.getElementById("saveProfileBtn").addEventListener("click", () => {
    const nameInput = document.getElementById("usernameInput").value.trim();
    const picSrc = document.getElementById("previewPic").src;

    if (!nameInput) { alert("Enter your name"); return; }
    if (!picSrc || picSrc === "") { alert("Upload a picture"); return; }

    username = nameInput;
    profilePic = picSrc;

    localStorage.setItem("username", username);
    localStorage.setItem("profilePic", profilePic);

    document.getElementById("loginScreen").style.display = "none";
    localVideo.style.display = "none";
    localPlaceholder.src = profilePic;
    localPlaceholder.style.display = "block";
    changeProfileBtn.style.display = "inline-block";

    showTopProfile();

    if (ws && ws.readyState === WebSocket.OPEN) {
        sendProfileToServer();
    } else {
        queuedProfileSend = true;
    }
});

changeProfileBtn.addEventListener("click", () => {
    stopLocalStream();
    localStorage.removeItem("username");
    localStorage.removeItem("profilePic");
    username = null;
    profilePic = null;

    localVideo.style.display = "none";
    localPlaceholder.src = "";
    localPlaceholder.style.display = "none";

    document.getElementById("loginScreen").style.display = "block";
    changeProfileBtn.style.display = "none";

    topAvatar.style.display = "none";
    userIdDisplay.textContent = "You (not logged in)";

    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "logout" }));
        ws.send(JSON.stringify({ type: "set_name", name: null }));
        ws.send(JSON.stringify({ type: "setProfile", username: null }));
    }
});

function sendProfileToServer() {
    if (!username) return;
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "setProfile", username: username, profilePic: profilePic }));
        ws.send(JSON.stringify({ type: "set_name", name: username }));
        queuedProfileSend = false;
        showTopProfile();
        log("Profile sent: " + username);
    } else {
        queuedProfileSend = true;
    }
}

/* ---------------- BROADCASTER GRID ---------------- */
function toggleBroadcasterList() {
    broadcasterListEl.style.display = broadcasterListEl.style.display === "none" ? "block" : "none";
}

function clearBroadcasterList() {
    broadcasterListEl.innerHTML = "<h4>Available Broadcasters:</h4>";
}

function updateBroadcasterDropdown(list) {
    const items = Array.isArray(list) ? list : (list && list.list) ? list.list : [];
    clearBroadcasterList();
    if (!items || items.length === 0) {
        broadcasterListEl.innerHTML += "<p>No broadcasters online.</p>";
        connectBtn.disabled = true;
        return;
    }

    connectBtn.disabled = true; // re-enable after selection

    items.forEach(b => {
        // create tile
        const entry = document.createElement("div");
        entry.className = "broadcaster-tile";
        entry.dataset.id = b.id;

        // avatar
        const img = document.createElement("img");
        img.className = "broadcaster-avatar";
        img.src = b.profilePic || "";
        img.alt = b.name || "Anon";

        // name
        const nameDiv = document.createElement("div");
        nameDiv.className = "broadcaster-name";
        nameDiv.textContent = b.name || "User";

        // join button
        const joinBtn = document.createElement("button");
        joinBtn.className = "btn-blue join-btn";
        joinBtn.textContent = (joinedBroadcasterId === b.id) ? "Joined" : "Join";
        if (joinedBroadcasterId === b.id) {
            entry.classList.add("joined");
            joinBtn.disabled = true;
        }

        // helper to mark tile joined/selected properly
        function markJoinedTile(id) {
            // clear previous highlights
            const tiles = broadcasterListEl.querySelectorAll(".broadcaster-tile");
            tiles.forEach(t => {
                if (t.dataset.id === id) {
                    t.classList.add("joined");
                    const btn = t.querySelector(".join-btn");
                    if (btn) { btn.textContent = "Joined"; btn.disabled = true; }
                } else {
                    t.classList.remove("joined");
                    const btn = t.querySelector(".join-btn");
                    if (btn) { btn.textContent = "Join"; btn.disabled = false; }
                }
            });
        }

        // click behavior : select and request connect immediately (Option C)
        entry.addEventListener("click", (ev) => {
            ev.stopPropagation();
            activeBroadcasterId = b.id;
            activeBroadcasterName = b.name || "Broadcaster";
            markJoinedTile(b.id); // visually select
            // set joined id so client knows it's joined (will remain until leave)
            joinedBroadcasterId = b.id;
            connectBtn.disabled = false;
            broadcasterStatus.textContent = "Selected Broadcaster: " + activeBroadcasterName;
            // request connection to that broadcaster (viewer flow)
            requestConnectAsViewer(); // uses activeBroadcasterId
        });

        // joinBtn explicit action
        joinBtn.addEventListener("click", (ev) => {
            ev.stopPropagation();
            activeBroadcasterId = b.id;
            activeBroadcasterName = b.name || "Broadcaster";
            markJoinedTile(b.id);
            joinedBroadcasterId = b.id;
            connectBtn.disabled = false;
            broadcasterStatus.textContent = "Selected Broadcaster: " + activeBroadcasterName;
            requestConnectAsViewer();
        });

        entry.appendChild(img);
        entry.appendChild(nameDiv);
        entry.appendChild(joinBtn);
        broadcasterListEl.appendChild(entry);
    });
}

/* ---------------- WEBSOCKET ---------------- */
function connectSignalingServer() {
    ws = new WebSocket(WS_URL);

    ws.onopen = () => {
        log("Connected to server");
        if (queuedProfileSend) sendProfileToServer();
    };

    ws.onmessage = (msg) => {
        let data;
        try { data = JSON.parse(msg.data); } catch (e) { return; }

        // assigned id (internal only)
        if (data.type === "id") {
            userId = data.id;
            // show display name (no UUID)
            showTopProfile();
            return;
        }

        if (data.type === "broadcaster_list") {
            updateBroadcasterDropdown(data.list || data);
            return;
        }

        if (data.type === "broadcaster_started") {
            // someone started broadcasting
            // show their name in status (no UUID)
            broadcasterStatus.textContent = "Broadcaster Online: " + (data.broadcasterName || data.name || "Broadcaster");
            if (data.list) updateBroadcasterDropdown(data.list);
            return;
        }

        if (data.type === "broadcaster_ended") {
            if (data.list) updateBroadcasterDropdown(data.list);
            broadcasterStatus.textContent = "No active broadcaster.";
            remoteVideo.srcObject = null;
            remoteStatus.textContent = "Awaiting Stream...";
            // if the broadcaster we joined ended, clear joined state
            if (joinedBroadcasterId === data.broadcasterId) {
                joinedBroadcasterId = null;
                // update top UI maybe
            }
            return;
        }

        if (data.type === "request_offer") {
            // broadcaster receives request from viewer -> create offer to viewer
            if (isBroadcasting && data.viewerId) {
                if (!pc) initPeerConnection();
                createOffer(data.viewerId);
                log("Creating offer for viewer: " + (data.viewerName || "viewer"));
            }
            return;
        }

        if (data.type === "offer") {
            // viewer receives offer from broadcaster
            const fromId = data.senderId;
            const fromName = data.senderName || "Broadcaster";
            log("Received offer from: " + fromName);
            // ensure local stream exists (viewer may not have camera)
            startLocalStream(false).then(() => createAnswer(data.sdp, fromId));
            return;
        }

        if (data.type === "answer") {
            if (pc) {
                pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
                log("Answer received from: " + (data.senderName || data.senderId));
            }
            return;
        }

        if (data.type === "candidate") {
            if (pc) {
                pc.addIceCandidate(new RTCIceCandidate(data.candidate)).catch(e => console.warn(e));
            }
            return;
        }

        log("Unknown message: " + JSON.stringify(data));
    };

    ws.onclose = () => {
        log("Disconnected - retrying...");
        setTimeout(connectSignalingServer, 1500);
    };

    ws.onerror = (e) => {
        console.warn("WebSocket error", e);
    };
}
connectSignalingServer();

/* ---------------- WEBRTC LOGIC ---------------- */
async function startLocalStream(isBroadcaster = false) {
    startBtn.disabled = true;
    stopBtn.disabled = false;

    const constraints = { video: { facingMode: cameraToggle.checked ? "user" : "environment" }, audio: true };

    try {
        localStream = await navigator.mediaDevices.getUserMedia(constraints);
        localVideo.srcObject = localStream;
        localVideo.style.display = "block";
        localPlaceholder.style.display = "none";
    } catch (err) {
        console.warn("Camera not available, using profile picture placeholder.");
        localVideo.style.display = "none";
        localPlaceholder.src = profilePic || "";
        localPlaceholder.style.display = "block";
    }

    isBroadcasting = isBroadcaster;
    if (isBroadcasting) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: "start_broadcast", name: username || null }));
        } else {
            log("Cannot start broadcast: signaling not open");
        }
        broadcasterStatus.textContent = "YOU ARE BROADCASTING";
    }

    initPeerConnection();
}

function stopLocalStream() {
    stopBtn.disabled = true;
    startBtn.disabled = false;

    if (localStream) localStream.getTracks().forEach(t => t.stop());
    localStream = null;

    if (isBroadcasting && ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "stop_broadcast" }));
    }

    stopPeerConnection();

    localVideo.style.display = "none";
    localPlaceholder.src = profilePic || "";
    localPlaceholder.style.display = "block";

    remoteVideo.srcObject = null;
    remoteStatus.textContent = "Awaiting Stream...";

    isBroadcasting = false;
}

function initPeerConnection() {
    pc = new RTCPeerConnection(PEER_CONFIG);
    if (localStream) localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

    pc.ontrack = (event) => { remoteVideo.srcObject = event.streams[0]; remoteStatus.textContent = ""; };

    pc.onicecandidate = (event) => {
        if (event.candidate && ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: "candidate", candidate: event.candidate, targetId: pc.targetId }));
        }
    };
}

function stopPeerConnection() { if (pc) pc.close(); pc = null; }

async function createOffer(viewerId) {
    if (!pc) initPeerConnection();
    pc.targetId = viewerId;
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "offer", sdp: offer, targetId: viewerId }));
        log("Offer sent to viewer");
    }
}

async function createAnswer(offer, broadcasterId) {
    if (!pc) initPeerConnection();
    pc.targetId = broadcasterId;
    await pc.setRemoteDescription(new RTCSessionDescription(offer));
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "answer", sdp: answer, targetId: broadcasterId }));
        log("Answer sent to broadcaster");
    }
}

function requestConnectAsViewer() {
    // use the currently selected activeBroadcasterId
    const targetId = activeBroadcasterId;
    const targetName = activeBroadcasterName || "Selected Broadcaster";
    if (!targetId) return alert("No broadcaster selected. Use 'Show Broadcasters' and pick one.");
    if (!username) {
        // better UX: ask user to set profile first
        return alert("Please set your name & profile picture first.");
    }
    if (ws && ws.readyState === WebSocket.OPEN) {
        // include viewerName so broadcaster gets friendly label
        ws.send(JSON.stringify({ type: "request_offer", targetId, viewerId: userId, viewerName: username }));
        // mark joined state (visual)
        joinedBroadcasterId = targetId;
        // update UI tiles (make sure clicked tile shows Joined)
        // delay small to allow server broadcaster_list update if necessary
        setTimeout(() => {
            const tiles = broadcasterListEl.querySelectorAll(".broadcaster-tile");
            tiles.forEach(t => {
                const btn = t.querySelector(".join-btn");
                if (t.dataset.id === targetId) {
                    t.classList.add("joined");
                    if (btn) { btn.textContent = "Joined"; btn.disabled = true; }
                } else {
                    t.classList.remove("joined");
                    if (btn) { btn.textContent = "Join"; btn.disabled = false; }
                }
            });
        }, 150);
        log("Requested connection to broadcaster: " + targetName);
    } else {
        alert("Signaling connection not open.");
    }
}
</script>
</body>
</html>