<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WebRTC Live Stream Client</title>

<style>
body {
    font-family: georgia;
    background: linear-gradient(to right, teal, maroon);
    border: 1px solid orange;
    border-radius: 4px;
    margin-top: 1px;
    color: orange;
    text-align: center;
    padding: 2px;
}

footer, h1 {
    border: 1px solid orange;
    border-radius: 4px;
    background: teal;
    margin: 2px;
    padding: 10px;
    color: orange;
}

h2 {
    border: 1px solid orange;
    border-radius: 6px;
    background: maroon;
    margin: 20px;
    font-size: 14px;
    padding: 8px;
    color: orange;
    text-align: center;
}

.container { max-width: 1100px; margin: auto; }
header { margin-bottom: 20px; }
.grid { display: grid; grid-template-columns: 1fr; gap: 20px; }
@media (min-width: 768px) { .grid { grid-template-columns: 1fr 1fr; } }

.card {
    background: linear-gradient(to right, maroon, teal);
    padding: 2px;
    border-radius: 14px;
    box-shadow: 0px 4px 14px rgba(0,0,0,0.2);
    color: black;
    text-align: left;
    border:1px solid orange;
}

.video-container { position: relative; width: 100%; aspect-ratio: 16 / 9; }
.video-feed { width: 100%; height: 100%; background-color: #1f2937; border-radius: 10px; object-fit: cover; transform: scaleX(-1); }
#remoteVideo { transform: scaleX(1); }

button { padding: 10px 15px; border-radius: 8px; border: none; cursor: pointer; color: white; font-weight: bold; }
.btn-green { background: teal; color: orange; }
.btn-red { background: maroon; color: orange; }
.btn-blue { background: orange; color: gray; }
button:disabled { opacity: 0.5; cursor: not-allowed; }

.flex-row { display: flex; gap: 10px; margin-top: 15px; }
.flex-between { display: flex; justify-content: space-between; align-items: center; }

#remoteStatus { position: absolute; inset: 0; background: rgba(0,0,0,0.5); border-radius: 10px; color: white; font-size: 18px; display: flex; align-items: center; justify-content: center; }

#statusConsole {
    background: #f3f4f6;
    padding: 12px;
    border-radius: 12px;
    height: 140px;
    overflow-y: scroll;
    font-size: 14px;
    border: 1px solid orange;
    color: teal;
}

.login-screen input[type="text"] { width: 90%; padding: 6px; margin-top: 6px; border-radius: 6px; border:1px solid orange; }
.login-screen input[type="file"] { margin-top:6px; }
.previewPic { width:60px;height:60px;border-radius:50%;display:none;margin-top:6px; }

#broadcasterList img { width:30px;height:30px;border-radius:50%;vertical-align:middle;margin-right:5px; }

#localPlaceholder { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; border-radius:10px; display:none; }
</style>
</head>

<body>
<div class="container">

<header>
<h1>Full Stack Live Stream</h1>

<div id="loginScreen" class="login-screen">
    <h2>Welcome</h2>

    <label>Your Name</label>
    <input type="text" id="usernameInput" placeholder="Enter your name">

    <label>Profile Picture</label>
    <input type="file" id="profilePicInput" accept="image/*">

    <img id="previewPic" class="previewPic"><br><br>

    <button id="saveProfileBtn">Save & Continue</button>
</div>

<p id="userIdDisplay" style="color:white;">Your ID: Connecting...</p>
<p id="broadcasterStatus" style="color:yellow;">Status: Waiting for Broadcaster.</p>
<p style="font-size:12px; margin-top:5px; color:lightcoral;">Note: P2P simulated connections.</p>
</header>

<div class="grid">

    <!-- LOCAL STREAM -->
    <div class="card">
        <h2>Your Camera</h2>
        <div class="video-container">
            <video id="localVideo" class="video-feed" autoplay playsinline muted></video>
            <img id="localPlaceholder" src="">
        </div>

        <div class="flex-row">
            <button id="startStreamBtn" onclick="startLocalStream(true)" class="btn-green">
                <span id="startText">Start Broadcast</span>
            </button>
            <button id="stopStreamBtn" onclick="stopLocalStream()" class="btn-red" disabled>Stop Broadcast</button>
        </div>

        <div class="flex-between" style="margin-top:15px;">
            <label>
                <input type="checkbox" id="frontCameraToggle" checked>
                <span style="margin-left:5px;">Use Front Camera</span>
            </label>

            <button id="connectBtn" onclick="requestConnectAsViewer()" class="btn-blue" disabled>
                Connect as Viewer
            </button>
        </div>

        <button id="changeProfileBtn" class="btn-blue" style="margin-top:10px; display:none;">
            Change Profile / Logout
        </button>
    </div>

    <!-- REMOTE STREAM -->
    <div class="card">
        <h2>Remote Broadcast Feed</h2>
        <div class="video-container">
            <video id="remoteVideo" class="video-feed" autoplay playsinline></video>
            <p id="remoteStatus">Awaiting Stream...</p>
        </div>
    </div>

</div><br>

<button onclick="toggleBroadcasterList()">Show Broadcasters ▼</button>
<div id="broadcasterList" style="display:none; background:white; color:black; padding:10px; margin:10px; border-radius:6px; border:1px solid orange;">
    Loading…
</div>

<div class="card" style="margin-top:20px;">
    <h3 style="margin-bottom:10px; text-align:center; color:teal;">System Console</h3>
    <div id="statusConsole"></div>
</div>

</div>
<footer style="font-size:10px;">&copy; 2025 Copyright SM Technology Live Streaming</footer>

<script>
/* ============================
   Client-side signaling & UI
   ============================ */

const WS_URL = (window.location.protocol === "https:" ? "wss://" : "ws://") + window.location.host;
let ws = null;
let pc = null;
let localStream = null;
let userId = null;
let username = null;
let profilePic = null;
let activeBroadcasterId = null;
let activeBroadcasterName = null;
let isBroadcasting = false;
let queuedProfileSend = false; // if profile saved before ws open

const localVideo = document.getElementById("localVideo");
const localPlaceholder = document.getElementById("localPlaceholder");
const remoteVideo = document.getElementById("remoteVideo");
const remoteStatus = document.getElementById("remoteStatus");
const consoleEl = document.getElementById("statusConsole");

const startBtn = document.getElementById("startStreamBtn");
const stopBtn = document.getElementById("stopStreamBtn");
const connectBtn = document.getElementById("connectBtn");
const cameraToggle = document.getElementById("frontCameraToggle");
const userIdDisplay = document.getElementById("userIdDisplay");
const broadcasterStatus = document.getElementById("broadcasterStatus");

const broadcasterListEl = document.getElementById("broadcasterList");
const changeProfileBtn = document.getElementById("changeProfileBtn");
let broadcasterDropdownVisible = false;

const PEER_CONFIG = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

function log(msg) {
    const p = document.createElement("p");
    p.textContent = msg;
    consoleEl.appendChild(p);
    consoleEl.scrollTop = consoleEl.scrollHeight;
}

/* ---------------- LOGIN & PROFILE ---------------- */
window.onload = () => {
    // load saved profile (if any)
    const savedName = localStorage.getItem("username");
    const savedPic = localStorage.getItem("profilePic");

    if (savedName && savedPic) {
        username = savedName;
        profilePic = savedPic;
        document.getElementById("loginScreen").style.display = "none";

        // show placeholder instead of camera until user starts broadcast
        localVideo.style.display = "none";
        localPlaceholder.src = profilePic;
        localPlaceholder.style.display = "block";

        changeProfileBtn.style.display = "inline-block";

        // If WS not connected yet, mark to send when ready
        queuedProfileSend = true;
    }
};

/* preview profile image */
document.getElementById("profilePicInput").addEventListener("change", function() {
    const file = this.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        document.getElementById("previewPic").src = e.target.result;
        document.getElementById("previewPic").style.display = "block";
    };
    reader.readAsDataURL(file);
});

/* save profile */
document.getElementById("saveProfileBtn").addEventListener("click", () => {
    const nameInput = document.getElementById("usernameInput").value.trim();
    const picSrc = document.getElementById("previewPic").src;

    if (!nameInput) { alert("Enter your name"); return; }
    if (!picSrc || picSrc === "") { alert("Upload a picture"); return; }

    username = nameInput;
    profilePic = picSrc;

    localStorage.setItem("username", username);
    localStorage.setItem("profilePic", profilePic);

    document.getElementById("loginScreen").style.display = "none";
    localVideo.style.display = "none";
    localPlaceholder.src = profilePic;
    localPlaceholder.style.display = "block";
    changeProfileBtn.style.display = "inline-block";

    // if ws open, send immediately, otherwise queue to send on open
    if (ws && ws.readyState === WebSocket.OPEN) {
        sendProfileToServer();
    } else {
        queuedProfileSend = true;
    }
});

/* Change Profile / Logout button */
changeProfileBtn.addEventListener("click", () => {
    stopLocalStream();
    localStorage.removeItem("username");
    localStorage.removeItem("profilePic");
    username = null;
    profilePic = null;

    localVideo.style.display = "none";
    localPlaceholder.src = "";
    localPlaceholder.style.display = "none";

    document.getElementById("loginScreen").style.display = "block";
    changeProfileBtn.style.display = "none";

    if (ws && ws.readyState === WebSocket.OPEN) {
        // notify server (compatible with either "logout" or "set_name" = empty)
        ws.send(JSON.stringify({ type: "logout" }));
        ws.send(JSON.stringify({ type: "set_name", name: null }));
        ws.send(JSON.stringify({ type: "setProfile", username: null }));
    }
});

function sendProfileToServer() {
    if (!username) return;
    if (ws && ws.readyState === WebSocket.OPEN) {
        // send both forms to support either server variant
        ws.send(JSON.stringify({ type: "set_name", name: username }));
        ws.send(JSON.stringify({ type: "setProfile", username: username, profilePic: profilePic }));
        queuedProfileSend = false;

        // update ID display to show name (if we already have userId, show both)
        userIdDisplay.textContent = "Logged in as: " + username + (userId ? " ("+userId+")" : "");
        log("Profile sent to server: " + username);
    } else {
        queuedProfileSend = true;
    }
}

/* ---------------- BROADCASTER DROPDOWN ---------------- */
function toggleBroadcasterList() {
    broadcasterDropdownVisible = !broadcasterDropdownVisible;
    broadcasterListEl.style.display = broadcasterDropdownVisible ? "block" : "none";
}

function updateBroadcasterDropdown(list) {
    // list may be full message object if server sent entire payload; normalize
    const items = Array.isArray(list) ? list : (list && list.list) ? list.list : [];
    broadcasterListEl.innerHTML = "<h4>Available Broadcasters:</h4>";
    if (!items || items.length === 0) {
        broadcasterListEl.innerHTML += "<p>No broadcasters online.</p>";
        return;
    }

    items.forEach(b => {
        const entry = document.createElement("div");
        entry.style.cursor = "pointer";
        entry.style.display = "flex";
        entry.style.alignItems = "center";
        entry.style.gap = "8px";
        entry.style.marginBottom = "6px";
        entry.style.padding = "6px";
        entry.style.borderRadius = "6px";

        const img = document.createElement("img");
        img.src = b.profilePic || b.pic || b.picUrl || "";
        img.alt = b.name || "Anon";
        img.style.width = "36px";
        img.style.height = "36px";
        img.style.borderRadius = "50%";
        img.style.objectFit = "cover";
        img.style.border = "1px solid #ddd";

        const nameSpan = document.createElement("span");
        nameSpan.textContent = b.name || b.username || ("User " + (b.id ? b.id.slice(0,6) : ""));

        entry.appendChild(img);
        entry.appendChild(nameSpan);

        entry.addEventListener("click", () => {
            activeBroadcasterId = b.id;
            activeBroadcasterName = b.name || b.username;
            connectBtn.disabled = false;
            broadcasterStatus.textContent = "Selected Broadcaster: " + (activeBroadcasterName || activeBroadcasterId);
            broadcasterListEl.style.display = "none";
            broadcasterDropdownVisible = false;
        });

        broadcasterListEl.appendChild(entry);
    });
}

/* ---------------- WEBSOCKET ---------------- */
function connectSignalingServer() {
    ws = new WebSocket(WS_URL);

    ws.onopen = () => {
        log("Connected to server");
        // If we had a profile waiting to send, do it now
        if (queuedProfileSend) sendProfileToServer();
    };

    ws.onmessage = (msg) => {
        let data;
        try { data = JSON.parse(msg.data); } catch (e) { return; }

        // server assigned id
        if (data.type === "id") {
            userId = data.id;
            // show chosen username if available, otherwise show id
            userIdDisplay.textContent = username ? ("Logged in as: " + username + " ("+userId+")") : ("Your ID: " + userId);
            return;
        }

        if (data.type === "broadcaster_list") {
            // server might send { type:'broadcaster_list', list: [...] }
            updateBroadcasterDropdown(data.list || data);
            return;
        }

        if (data.type === "broadcaster_started") {
            // server may send broadcasterName and optionally list
            activeBroadcasterId = data.broadcasterId;
            activeBroadcasterName = data.broadcasterName || data.name || null;

            broadcasterStatus.textContent = "Broadcaster Online: " + (activeBroadcasterName || activeBroadcasterId);
            // update list if server provided it
            if (data.list) updateBroadcasterDropdown(data.list);
            connectBtn.disabled = false;
            return;
        }

        if (data.type === "broadcaster_ended") {
            activeBroadcasterId = null;
            activeBroadcasterName = null;
            broadcasterStatus.textContent = "No active broadcaster.";
            connectBtn.disabled = true;
            remoteVideo.srcObject = null;
            remoteStatus.textContent = "Awaiting Stream...";
            if (data.list) updateBroadcasterDropdown(data.list);
            return;
        }

        // A broadcaster received a viewer request (server forwards viewer's request to broadcaster)
        if (data.type === "request_offer") {
            // if I am the broadcaster, create offer to the viewer
            if (isBroadcasting && data.viewerId) {
                // ensure peer connection exists
                if (!pc) initPeerConnection();
                createOffer(data.viewerId);
            }
            return;
        }

        // Offer sent from broadcaster to viewer
        if (data.type === "offer") {
            // viewer receives offer (server should include senderId/to/from semantics)
            const from = data.senderId || data.from || data.broadcasterId;
            startLocalStream(false).then(() => createAnswer(data.sdp, from));
            return;
        }

        // Answer from viewer to broadcaster
        if (data.type === "answer") {
            if (pc) pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
            return;
        }

        // ICE candidate
        if (data.type === "candidate") {
            if (pc) pc.addIceCandidate(new RTCIceCandidate(data.candidate)).catch(e => console.warn(e));
            return;
        }

        // legacy support: server might send full list object as message for update
        if (Array.isArray(data)) {
            updateBroadcasterDropdown(data);
            return;
        }

        // debug
        log("Unknown message: " + JSON.stringify(data));
    };

    ws.onclose = () => {
        log("Disconnected from signaling server - retrying...");
        setTimeout(connectSignalingServer, 1500);
    };

    ws.onerror = (e) => {
        console.warn("WebSocket error", e);
    };
}
connectSignalingServer();

/* ---------------- WEBRTC LOGIC ---------------- */
async function startLocalStream(isBroadcaster = false) {
    startBtn.disabled = true;
    stopBtn.disabled = false;

    const constraints = { video: { facingMode: cameraToggle.checked ? "user" : "environment" }, audio: true };

    try {
        localStream = await navigator.mediaDevices.getUserMedia(constraints);
        localVideo.srcObject = localStream;
        localVideo.style.display = "block";
        localPlaceholder.style.display = "none";
    } catch (err) {
        console.warn("Camera not available, showing profile picture.");
        localVideo.style.display = "none";
        localPlaceholder.src = profilePic || "";
        localPlaceholder.style.display = "block";
    }

    isBroadcasting = isBroadcaster;
    if (isBroadcasting) {
        // send both name-only and profile variant for server compatibility
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: "start_broadcast", name: username || null }));
            ws.send(JSON.stringify({ type: "start_broadcast_profile", broadcasterId: userId, name: username || null, profilePic: profilePic || null }));
        }
        broadcasterStatus.textContent = "YOU ARE BROADCASTING";
    }

    initPeerConnection();
}

function stopLocalStream() {
    stopBtn.disabled = true;
    startBtn.disabled = false;

    if (localStream) localStream.getTracks().forEach(t => t.stop());
    localStream = null;

    if (isBroadcasting && ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "stop_broadcast" }));
    }

    stopPeerConnection();

    localVideo.style.display = "none";
    localPlaceholder.src = profilePic || "";
    localPlaceholder.style.display = "block";

    remoteVideo.srcObject = null;
    remoteStatus.textContent = "Awaiting Stream...";

    isBroadcasting = false;
}

function initPeerConnection() {
    pc = new RTCPeerConnection(PEER_CONFIG);
    if (localStream) localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

    pc.ontrack = (event) => { remoteVideo.srcObject = event.streams[0]; remoteStatus.textContent = ""; };

    pc.onicecandidate = (event) => {
        if (event.candidate && ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: "candidate", candidate: event.candidate, targetId: pc.targetId }));
        }
    };
}

function stopPeerConnection() { if (pc) pc.close(); pc = null; }

async function createOffer(viewerId) {
    if (!pc) initPeerConnection();
    pc.targetId = viewerId;
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "offer", sdp: offer, targetId: viewerId }));
    }
}

async function createAnswer(offer, broadcasterId) {
    if (!pc) initPeerConnection();
    pc.targetId = broadcasterId;
    await pc.setRemoteDescription(new RTCSessionDescription(offer));
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "answer", sdp: answer, targetId: broadcasterId }));
    }
}

function requestConnectAsViewer() {
    // attempt to use selected broadcaster, fallback to activeBroadcasterId
    const targetId = activeBroadcasterId;
    if (!targetId) return alert("No broadcaster selected. Use 'Show Broadcasters' and pick one.");
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "request_offer", viewerId: userId }));
        log("Requested connection to broadcaster: " + targetId);
    } else {
        alert("Signaling connection not open.");
    }
}
</script>
</body>
</html>